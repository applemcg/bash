setpath () 
{ 
    case $1 in 
        */bin)
            pushd $1 > /dev/null;
            case $PATH in 
                *:$PWD:* | *:$PWD | $PWD:*)

                ;;
                *)
                    PATH=$PATH:$PWD;
                    export PATH
                ;;
            esac;
            popd > /dev/null
        ;;
        *)
            echo "USAGE: setpath {some}/bin" 1>&2
        ;;
    esac
}
pathlib () 
{ 
    function do_set_path () 
    { 
        echo .;
        echo $PATH | tr ':' '\012' | grep /bin | sed "s/\/bin/\/$1/"
    };
    function do_which_path () 
    { 
        for dir in $(do_set_path include);
        do
            [[ -f $dir/$1 ]] && { 
                printf "%s" $dir/$1;
                return
            };
        done
    };
    case $1 in 
        set | which)
            c=$1;
            shift;
            do_${c}_path $*
        ;;
        *)
            comment set_path OR whipath
        ;;
    esac
}
set_path	() { pathlib set $1 | tr '\012' ':'; }
whipath	() { pathlib which $*; }
require () 
{ 
    tool=$1;
    shift;
    bin=$1/bin;
    shift;
    paths | grep $bin || return;
    set -- $(which $tool);
    [[ "$1" == $bin/$tool ]] && return;
    setpath $bin
}
setpath_doc	() { comment bkup: Patricias-MacBook-Air.local./Users/applemcg/Dropbox/bin 2013_0902 075934; }
setpath_init () 
{ 
    : ${INCLUDE_PATH:=$(set_path include)};
    comment setpath_doc
}
paths	() { eval echo \$${1:-PATH} | sed 's/::/:.:/' | tr : '\012'; }
bitmeld () 
{ 
    pushd ${1:-.} > /dev/null;
    while true; do
        case $PWD in 
            /)
                break
            ;;
            *)
                for dir in src bin include tmp man etc lib doc;
                do
                    [[ -d $dir ]] && break 2;
                done;
                cd ..
            ;;
        esac;
    done;
    pwd;
    popd > /dev/null
}
setpath_init 1>&2
