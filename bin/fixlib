canonlib () 
{ 
    f=$1;
    shift;
    bkup $f;
    ( fbdy $(functions $f | ${*:-cat});
    echo ${f}_init ) > .y;
    mv .y $f;
    bkup $f
}
fixlib () 
{ 
    source $1;
    fbdy $(tflib $1 | field 1) >> $1;
    source $1;
    fbdy $(tflib $1 | field 1) | tee -a $1;
    edsave $1
}
tflib () 
{ 
    tmp=/tmp/tflib;
    rm -f $tmp.*;
    is F $1;
    canonflag $F | awk '$2 ~ /^\(\)$/ && NF>2' | tee $tmp.$$;
    [[ ! -s $tmp.$$ ]]
}
canonflag () 
{ 
    sed 's/ *( *) */ () /' $1
}
edsave () 
{ 
    vi $1;
    bkup $1;
    source $1;
    logUse fixlib.edsave sourced $1
}
fixlib_idea () 
{ 
    echo "\"source newlib\" is way too generic for this library"
}
fixapp_init () 
{ 
    fixlib_help;
    mkdir -p .names;
    integ_doc 1>&2
}
fixlib_init () 
{ 
    source bootlib;
    sourceOneTime blib;
    logUse fixlib sourced blib;
    logUse fixlib uses programlib;
    fixapp_init
}
fixlib_help () 
{ 
    cat 1>&2  <<EOF
0. fixlib_help
   annotate {libname}

1. tflib {libname}

  if nothing, NEXT lib,
  else ...
2. fixlib {libname}
   edsave {libname}

  until satisfied, then
3. canonlib {libname}
EOF

}
annotate () 
{ 
    fundef="$1Idea ()";
    cat >> ${1}lib  <<EOF
$fundef
{
    echo "$2"
}    
EOF

}
sav1f () 
{ 
    fbdy $2 > .mrg/$1/$2
}
samef () 
{ 
    comm -12 $1 $2
}
savlibf () 
{ 
    source $1 2> /dev/null;
    logUse fixlib.savlibf sourced $1;
    foreachi sav1f $1 $(samef .$1 .$2)
}
integA () 
{ 
    flist $1 > /dev/null;
    flist $2 > /dev/null;
    mkdir -p .mrg/$1 .mrg/$2 .mrg/ifdiff;
    savlibf $1 $2;
    savlibf $2 $1;
    for f in $(samef .$1 .$2);
    do
        diff .mrg/*lib/$f > .mrg/ifdiff/$f;
    done;
    wc -l .mrg/ifdiff/* | awk '$1 > 1 && $2 !~ /^total$/ { print $2}' > .ifdiff;
    cat $(sed "s/ifdiff/$1/" .ifdiff) > com$1;
    cat $(sed "s/ifdiff/$2/" .ifdiff) > com$2;
    rm -fr .mrg/*;
    echo ${EDIT:-vi} com$1 com$2
}
integ_doc () 
{ 
    comment "# Copyright (C) 2005-2013, JYATL - Just Yet Another Testing Lab";
    comment bkup: appleton.home./Users/applemcg/bin 2013_0117 153649;
    cat  <<'EOF'

    usage: integA libA libB

    where libA, B are separate instances of LIB, requring INTEGRATION.
    e.g. they've undergone separate changes, and need merging.

    Two files result:  comlibA and comlibB    which have the copies
    of the differing functions which share the same name in the libraries.

    Edit one or the other, say comlibB to have the desired copy of
    each function.   Then, conclude the integration with these steps:

        $ source libA
        $ source libB
        $ source comlibB
        $ fbdy $(functions libA libB) > nextlibA

    Then  nextlibA  is allegedly the library you are looking for.
    Inspect it for completeness and spill-over since there may be
    some functions from libB you didn't need.

EOF

}
itsLib () 
{ 
    whf $1 | sed 1q | field 1
}
ffinlib () 
{ 
    whfOK $1 || { 
        comment too many $1 $(whf $1);
        eturn
    };
    ffun $1;
    fbdy $1 | append $(itsLib $1 )
}
forgotAppend () 
{ 
    cat .bak/$1 $1 > .y;
    mv .y $1
}
functions_users () 
{ 
    ignore pushd ~/bin;
    for l in *lib;
    do
        cgrepf functions $l | sed "s/^/$l$(tab)/";
    done | sort | tee .functions.used | field 2 | sort -u | grep -v _doc;
    ignore popd
}
foreach () 
{ 
    local cmd=$1;
    shift;
    for arg in "$@";
    do
        $cmd $arg;
    done
}
canlib () 
{ 
    f=$1
    exists ${1}lib && f=${1}lib
    source $f >/dev/null;
    fbdy $(functions $f);
    echo ${2:-${1}_init}
}
prepnew () 
{ 
    canlib $* | tee .$1.new | diff $1 - 1>&2;
    echo mv .$1.new $1
}
fixlib_init
