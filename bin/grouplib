group_appinit () 
{ 
    group_doc 1>&2;
    fbdy group_appinit 1>&2
}
group_init () 
{ 
    source programlib 2> /dev/null;
    group_appinit
}
group_name () 
{ 
    set -- ${1:-empty} ${2:-EMPTY};
    fbdy $2 || { 
        comment $2 is NOT a function;
        return
    };
    fbdy $2 | sed "s/$2/${1}_$2/"
}
group_collect () 
{ 
    set -- ${1%lib};
    set -- ${1}lib $(basename $1);
    comment TRACE group_collect LIBRARY $1 BASENAME $2;
    [[ -f ${1} ]] || { 
        comment ${1} is NOT a lib;
        return
    };
    . $1;
    fbdy $(functions ${1});
    echo ${2}_init
}
group_doc () 
{ 
    cat  <<EOF

group library    -- functions to collect functions in groups
-------------
group_appinit -- when you initialize the appliction
group_init    -- the only permissible default behavior when sourceing
group_collect -- ~ group      collects groups functions, tacks on init
group_ungroup -- ~ group      takes all the ungrouped in the group library.
group_name    -- ~ group function     turns function into  group_function
group_takes   -- ~ group function     redefines function as using group_function

EOF

}
group_takes () 
{ 
    eval "$2 () { comment OBSOLESCENT $2 USING ${1}_$2; ${1}_$2 \$*; }"
}
group_ungroup () 
{ 
    foreachi group_takes $1 $(functions ${1}lib | grep -v $1)
}
group_init
