comment () 
{ 
    echo $* 1>&2
}
cpfmto () 
{ 
    doit rm -f $2;
    doit cp $1 $2;
    doit chmod ${3:--w} $2
}
mk_each () 
{ 
    case $1 in 
        each | all)

        ;;
        *)
            f=mk_${1};
            isfunction $f && $f
        ;;
    esac
}
mk_frm () 
{ 
    comment TRACE mk_frm $# OUTPUT "$1", COMMAND "$2", args "$3", ...;
    mk_qst "$@" || { 
        shift;
        doit "$@"
    };
    quietly comment 'o=$1; shift; c=$1; shift; newest $o $@ || doit $c $*;'
}
mk_ln () 
{ 
    set -- $(basename $1) ${2:-$(dirname $1)};
    comment TRACE mk_ln FILE $1 DIR $2;
    exists $2/$1 || doit ln $1 $2
}
mk_me () 
{ 
    comment TRACE mk_me $# CMD "$1" COLLECT "$@";
    cmd=$1;
    shift;
    MK_COLLECT="$MK_COLLECT $*";
    newest $* || { 
        bkup $*;
        doit $cmd $(shifted $*) > $1 2> ${2%.*}.err
    }
}
mk_one () 
{ 
    comment TRACE mk_one $# OUTPUT "$1", COMMAND "$2", ARGS "$3", ...;
    mk_qst "$@" && { 
        comment MK_QST has found $1 is UP TO DATE wrt $(shifted $*);
        return
    };
    comment MK_QST has found work to UPDATE $1 with;
    [[ -f "$1" ]] && chmod +w "$1";
    comment TRACE shell_stdout $# $@;
    shell_stdout "$@";
    chmod -w "$1"
}
mk_qst () 
{ 
    comment TRACE mk_qst $# "$@";
    o="$1";
    shift;
    c="$1";
    shift;
    newest "$o" "$@"
}
mmk_init () 
{ 
    source programlib;
    . listlib;
    comment bkup: Patricias-MacBook-Air.local./Users/applemcg/Dropbox/bin 2013_0903 221958;
    function qi_mk () 
    { 
        eval "qi${1} () { qia $2 \$1; }"
    };
    qi_mk i include;
    qi_mk e etc;
    qi_mk t tmp;
    qi_mk d doc;
    setOrGet qi_root;
    qi_root $HOME;
    comment qiX where X one of b,i,t,m,e,l,d file;
    comment to see a function, declare -f qiX;
    comment also mmk_qrf for a Quick Reference;
    unset qi_mk
}
mmk_qrf () 
{ 
    cat  <<EOF
addlist	-- ~ list member: adds member to list
bitmeld	-- creates smart BITMELD directory at first argument, defaulting to HOME
comment	-- args: puts args on standard error
cpfmto	-- destrucively copies 1st to 2nd, mode of 3rd, default "-w"
defun	-- ~ function body
deploytextfiles	-- copies files to text destinations, with mode 444
domode	-- ~ file [mode [-w]]
exists	-- ~ file  RETURNS true for existing file argument
foreach1	-- "commands: ..." arg ... EXECUTES quoted commands on each arg
mk_all	-- shorthadn for "foreach mk_each $*"
mk_each	-- ~ fun, executes  "mk_fun" 
mk_frm	-- ~ TARGET Cmd Depends: like mk_one. TARGET implicitly created
mk_ln	-- ~ file [dir [basename file]]: links local file to nonexistent dir/file
mk_me	-- ~ cmd target depends ... redundant to mk_one?  test...
mk_one	-- TARGET Cmd Depends ...: runs Cmd on Depends Stdout TARGET
mk_qst	-- return truth of newest TARGET Cmd Depends
mkall	-- historical, prefer equivalent QIx
mkbin	--  historical, prefer qib
mkdoc	--  historical, prefer qid
mketc	--  historical, prefer qie
mkexec	--  copies executable files to BITMELD/bin at mode 555
mkhelp	-- help message
mkit	-- engine for mkall
mklib	--  historical, prefer qil
mkman	--  historical, prefer qim
mktext	-- deployes textfiles
needir	-- creates missing directory, returns Name
newest	-- heart of MK algo,   thx to Dan Franklin, BBN, 1984
primarysource	-- ~ file list: adds file to list for mkall
qi	-- obsolescent QIB
mmk_init	-- Master Make INITialzation, from qilib, mfg QI [edit]
qia	-- Quick Install Any. tool for QIx using  links
qib	-- QI Bin
qil	-- QI Lib
qim	-- QI Man
textfile	-- ~ file dir: adds file, dir destination to textfiles list
EOF

}
needir () 
{ 
    [[ -d $1 ]] || mkdir -p $1;
    echo $1
}
newest () 
{ 
    comment TRACE newest $# TARGET "$1" DEPENDENT "$@";
    target="$1";
    shift;
    [[ -f "$target" ]] || { 
        comment NEWEST with NO $target;
        return 1
    };
    while [[ -n "$1" ]]; do
        [[ "$target" -ot "$1" ]] && { 
            comment NEWEST with $1 NEWER than $target;
            return 1
        };
        shift;
    done;
    comment NEWEST with $target as NEWEST argument;
    return 0
}
qi () 
{ 
    comment OBSOLESCENT use qib $1;
    rm -f ~/bin/$1;
    chmod 755 $1;
    ln $1 ~/bin
}
qi_ball () 
{ 
    qi_bone /Volumes/MIT_130716/;
    qi_bone ~/Dropbox/;
    qi_bone $HOME
}
qi_bone () 
{ 
    qi_root $1;
    foreach qib *lib;
    touch .qi_bone
}
qi_lncp () 
{ 
    comment TRACE qi_lncp $# FILE $1 DIR $2;
    eval $(same_dev $1 $2 && echo ln || echo cp) $1 $2
}
qia () 
{ 
    set -- $(qi_root)/$1 $2;
    [[ $PWD == $1 ]] && return;
    rm -f $(needir $1)/$2;
    chmod -w $2;
    qi_lncp $2 $1
}
qib () 
{ 
    qia bin $1;
    chmod +x $1
}
qil () 
{ 
    qia lib/$2 $1
}
qim () 
{ 
    qia man/man${2:-1} $1
}
same_dev () 
{ 
    eval $(stat -s $1);
    one=$st_dev;
    eval $(stat -s $2);
    two=$st_dev;
    [[ $one -eq $two ]]
}
shell_stdout () 
{ 
    comment TRACE shell_stdout $# "$@";
    o="$1";
    shift;
    "$@" > "$o"
}
smartf_is () 
{ 
    [[ $# -gt 1 ]] && { 
        eval _smartf_is_$1="$2"
    };
    eval echo \$_smartf_is_$1
}
mmk_init 1>&2
