comment	() { echo $* 1>&2; }
cpfmto () 
{ 
    doit rm -f $2;
    doit cp $1 $2;
    doit chmod ${3:--w} $2
}
mk_each () 
{ 
    case $1 in 
        each | all)

        ;;
        *)
            f=mk_${1};
            isfunction $f && $f
        ;;
    esac
}
mk_frm () 
{ 
    comment TRACE mk_frm $# OUTPUT "$1", COMMAND "$2", args "$3", ...;
    mk_qst "$@" || { 
        shift;
        doit "$@"
    };
    quietly comment 'o=$1; shift; c=$1; shift; newest $o $@ || doit $c $*;'
}
mk_ln () 
{ 
    set -- $(basename $1) ${2:-$(dirname $1)};
    comment TRACE mk_ln FILE $1 DIR $2;
    exists $2/$1 || doit ln $1 $2
}
mk_me () 
{ 
    comment TRACE mk_me $# CMD "$1" COLLECT "$@";
    cmd=$1;
    shift;
    MK_COLLECT="$MK_COLLECT $*";
    newest $* || { 
        bkup $*;
        doit $cmd $(shifted $*) > $1 2> ${2%.*}.err
    }
}
mk_one () 
{ 
    comment TRACE mk_one $# OUTPUT "$1", COMMAND "$2", ARGS "$3", ...;
    mk_qst "$@" && { 
        comment MK_QST has found $1 is UP TO DATE wrt $(shifted $*);
        return
    };
    comment MK_QST has found work to UPDATE $1 with;
    [[ -f "$1" ]] && chmod +w "$1";
    comment TRACE shell_stdout $# $@;
    shell_stdout "$@";
    chmod -w "$1"
}
mk_qst () 
{ 
    comment TRACE mk_qst $# "$@";
    o="$1";
    shift;
    c="$1";
    shift;
    newest "$o" "$@"
}
mmk_init () 
{ 
    source programlib;
    . listlib;
    comment bkup: Patricias-MacBook-Air.local./Users/applemcg/Dropbox/bin 2013_0903 221958;
    function qi_mk () 
    { 
        eval "qi${1} () { qia $2 \$1; }"
    };
    qi_mk i include;
    qi_mk e etc;
    qi_mk t tmp;
    qi_mk d doc;
    setOrGet qi_root;
    qi_root $HOME;
    comment qiX where X one of b,i,t,m,e,l,d file;
    comment to see a function, declare -f qiX;
    comment also mmk_qrf for a Quick Reference;
    unset qi_mk
}
mmk_qrf () 
{ 
    cat  <<EOF
comment	-- args: puts args on standard error
cpfmto	-- destrucively copies 1st to 2nd, mode of 3rd, default "-w"
mk_all	-- shorthadn for "foreach mk_each "
mk_each	-- ~ fun, executes  "mk_fun" 
mk_frm	-- ~ TARGET Cmd Depends: like mk_one. TARGET implicitly created
mk_ln	-- ~ file [dir [basename file]]: links local file to nonexistent dir/file
mk_me	-- ~ cmd target depends ... redundant to mk_one?  test...
mk_one	-- TARGET Cmd Depends ...: runs Cmd on Depends Stdout TARGET
mk_qst	-- return truth of newest TARGET Cmd Depends
mkbin	--  historical, prefer qib
mkdoc	--  historical, prefer qid
mketc	--  historical, prefer qie
mklib	--  historical, prefer qil
mkman	--  historical, prefer qim
needir	-- creates missing directory, returns Name
newest	-- heart of MK algo,   thx to Dan Franklin, BBN, 1984
qi	-- obsolescent QIB
mmk_init	-- Master Make INITialzationd, mfg QI [edit]
qia	-- Quick Install Any. tool for QIx using  links
qib	-- QI Bin
qil	-- QI Lib
qim	-- QI Man
EOF

}
needir () 
{ 
    [[ -d $1 ]] || mkdir -p $1;
    echo $1
}
newest () 
{ 
    comment TRACE newest $# TARGET "$1" DEPENDENT "$@";
    target="$1";
    shift;
    [[ -f "$target" ]] || { 
        comment NEWEST with NO $target;
        return 1
    };
    while [[ -n "$1" ]]; do
        [[ "$target" -ot "$1" ]] && { 
            comment NEWEST with $1 NEWER than $target;
            return 1
        };
        shift;
    done;
    comment NEWEST with $target as NEWEST argument;
    return 0
}
qi () 
{ 
    comment OBSOLESCENT use qib $1;
    rm -f ~/bin/$1;
    chmod 755 $1;
    ln $1 ~/bin
}
qi_lncp () 
{ 
    comment TRACE qi_lncp $# FILE $1 DIR $2;
    eval $(same_dev $1 $2 && echo ln || echo cp) $1 $2
}
qia () 
{ 
    set -- $(qi_root)/$1 $2;
    [[ $PWD == $1 ]] && return;
    rm -f $(needir $1)/$2;
    chmod -w $2;
    qi_lncp $2 $1
}
qib () 
{ 
    qia bin $1;
    chmod +x $1
}
qil	() { qia lib/$2 $1; }
qim	() { qia man/man${2:-1} $1; }
same_dev () 
{ 
    eval $(stat -s $1);
    one=$st_dev;
    eval $(stat -s $2);
    two=$st_dev;
    [[ $one -eq $two ]]
}
