programlib_init () 
{ 
    comment "Copyright (C) 2011-2013, JYATL -- Just YA Testing Lab";
    comment "mailto: mcgowan (at) alum DOT mit DOT edu";
    source bootlib;
    obsolescent file_test testarg;
    obsolescent fileTest testarg;
    obsolescent piped pipe;
    obsolescent is_a_function isfunction;
    setenv AWK $(getawk);
    testarg empty z;
    testarg executable x;
    testarg existingdir d;
    testarg exists e;
    testarg existingfile f;
    testarg nonempty s;
    testarg writeable w;
    self_ref programlib_eval myfunctions obsolescent rlib testarg self_ref
}
stdout () 
{ 
    o=$1;
    shift;
    "$@" > $o
}
pipe () 
{ 
    eval $(shifted $@) | $1
}
run_test () 
{ 
    doit $*
}
foreach () 
{ 
    local cmd=$1;
    shift;
    for arg in "$@";
    do
        $cmd $arg;
    done
}
nonempty () 
{ 
    [[ -s $1 ]]
}
shifted () 
{ 
    shift;
    echo "$@"
}
liblib_obsolescent () 
{ 
    foreach rlib $(liblib_users)
}
Mkdir () 
{ 
    doit mkdir -p $*
}
ignore () 
{ 
    "$@" > /dev/null
}
setenv () 
{ 
    eval $1=\"$2\";
    export $1
}
libfunc () 
{ 
    sed 's/ *( *) */ () /' $* | egrep -v '["\$]' | awk '
     $2 ~ /^\(\)$/ && printed[$1]++ < 1	{ print $1 }
     '
}
obsolescent () 
{ 
    eval "$1() { comment OBSOLESCENT in behalf of $2; $2 \$@; }"
}
nonUnderscore () 
{ 
    grep -v _ $*
}
generic_lib () 
{ 
    lib=${1:-programlib};
    case $2 in 
        init)
            copyrightNotice;
            ${lib}_init
        ;;
        start)
            $lib init;
            $lib help
        ;;
        help)
            comment -- $lib function list --;
            generic_lib $lib | sort -u 1>&2;
            comment --------------------;
            comment "e.g. fbdy"
        ;;
        *)
            $lib help
        ;;
    esac
}
wh () 
{ 
    which $1
}
getawk () 
{ 
    wh gawk || wh nawk || wh awk
}
error () 
{ 
    comment "$@";
    exit $#
}
foreachi () 
{ 
    local par="$1 $2";
    shift 2;
    for a in "$@";
    do
        $par $a;
    done
}
shift2 () 
{ 
    shift;
    shift;
    echo $*
}
not () 
{ 
    if { 
        eval "$@"
    }; then
        false;
    else
        true;
    fi
}
dirname () 
{ 
    case $1 in 
        */*)
            echo ${1%/*}
        ;;
        *)
            echo .
        ;;
    esac
}
basename () 
{ 
    echo ${1##*/}
}
newest () 
{ 
    target=$1;
    shift;
    [[ -f $target ]] || return 1;
    while [[ -n $1 ]]; do
        [[ $target -ot $1 ]] && return 1;
        shift;
    done;
    return 0
}
wpl () 
{ 
    cat ${*:--} | /usr/bin/tr -cs "[A-Z][a-z][0-9]_" '[\012*]'
}
toupper () 
{ 
    tr '[a-z]' '[A-Z]'
}
tolower () 
{ 
    tr '[A-Z]' '[a-z]'
}
subtract () 
{ 
    cat ${2:--} | sort -u | comm -23 $1 -
}
field () 
{ 
    awk "{ print \$$1 }"
}
indir () 
{ 
    ignore pushd $1;
    shift;
    $@;
    ignore popd
}
nava () 
{ 
    eval echo $1 \$$1
}
printfirst () 
{ 
    awk 'printed [$1]++ < 1' $*
}
cleanlib () 
{ 
    fbdy $(libfunc $1 | printfirst);
    echo ${1}_init
}
libfunctions () 
{ 
    sed 's/( *)/ () /' $* | tee .sh.in | awk '$2 ~ /\(\)/ {print $1}'
}
testarg () 
{ 
    eval "$1() { [[ -$2 \$1 ]]; }"
}
programIdea () 
{ 
    echo "remove the _uses in behalf of uses function, has ..."
}
de () 
{ 
    f=/tmp/de.$$;
    rm -f $f;
    ${EDITOR:-vi} $f;
    ( _de_hdr;
    cat $f .diary ) > .y.$$;
    mv .y.$$ .diary
}
fnames () 
{ 
    [[ -d .names ]] || mkdir -p .names;
    suf=${1:-stdin};
    libfunc $* | tee .names.$suf | sort -u > .names/$suf;
    cat .names.$suf && rm -f .names.$suf
}
system () 
{ 
    uname -s
}
uc () 
{ 
    tr a-z A-Z
}
lc () 
{ 
    cat ${*:--} | tr '[A-Z]' '[a-z]'
}
today () 
{ 
    date +%Y%m%d
}
programlib_doc () 
{ 
    cat  <<'EOF'
	-- programlib defines: 
auname	--
basename	-- file portion of the argument, see dirname
cleanlib	--
comment	-- echos to the standard error
copyrightNotice	--
de	--
dirname	-- the directory portion of the argument, default "."
doit	-- comment, then eval
error	-- comment, then exit
field	-- the Nth blank-separated field
fnames	--
foreach	-- ~ cmd ...   execuctes  "cmd" on each arg
foreachi	-- ~ cmd One arg ... executes "cmd One" on each arg
generic_lib	--
getawk	-- who's your "awk"
ignore	-- executes command, disposing stdout
indir	-- ~ DIR cmd ...  executes "cmd ..." in DIR
isfunction	-- true if argument is a function
lc	-- Lower Case, see tolower, toupper, uc
libfunc	--
libfunctions	--
liblib_obsolescent	--
Mkdir	-- 
myfunctions	-- CONSTRUCTOR: ~ alib [drive B], is alias for "functions alib"
nava	-- NAme VAlue 
newest	-- ~ FileA fileb ...  TRUE, when filea is the newest
nonempty	--
nonUnderscore	--
not	-- ~ cmd ... inverts logical sense of the cmd ...
obsolescent	--
pipe	-- 
printfirst	-- prints first occurrence of line of text
programIdea	--
programlib_init	--
run_test	--
self_ref	-- CONSTRUCTOR: namea nameb ...  "namea" lists namea ... z
setenv	-- ~ NAME Value,   just like the csh built-in
shift2	-- ~ a b c d e ... returns "c d e ..."
shifted	-- ~ a b c d e ... returns "b c d e ..."
stdout	-- ~ arg cmd args ...  "cmd args ... > arg"
subtract	-- set subtraction 2nd list from first with comm -23
system	-- uname -s
testarg	-- CONSTRUCTOR: ~ name [a-z]; creates "name", function uses test arg
today	-- YYMMDD
tolower	--
toupper	--
uc	-- Upper Case	--
wh	-- which 	--
wpl	-- Words Per Line	--

EOF

}
self_ref () 
{ 
    eval "$1 () { \${1:-echo} $*; }"
}
bitbucket () 
{ 
    eval $@ 2> /dev/null
}
onlyfiles () 
{ 
    for arg in ${*:-*};
    do
        [[ -f $arg ]] && echo $arg;
    done
}
onlydirs () 
{ 
    for arg in ${*:-*};
    do
        [[ -d $arg ]] && echo $arg;
    done
}
fmdos () 
{ 
    cat ${*:--} | tr -d '\015'
}
append () 
{ 
    tee -a $1
}
script_path () 
{ 
    function _scrpath_zero () 
    { 
        while ( [ -h "$1" ] ); do
            set -- $(readlink "$1");
        done;
        pushd . > /dev/null;
        cd $(dirname "$1");
        pwd;
        popd > /dev/null
    };
    _scrpath_zero ${BASH_SOURCE[0]}
}
defExe () 
{ 
    which $1 > /dev/null 2>&1 && echo $1 || echo $2
}
repeated () 
{ 
    count=${2:-2};
    result=;
    while [ $count -gt 0 ]; do
        result=$result$1;
        let count-=1;
    done;
    echo $result
}
popla () 
{ 
    sort -n | field 1 | uniq -c
}
mac2unix () 
{ 
    cat ${*:--} | tr '\r' '\n';
    echo
}
collect_eval () 
{ 
    indir ~/bin cgrepf eval '*lib' | grep '1 *()' | field 1 | sort -u
}
foreachij () 
{ 
    local par="$1 $2 $3";
    shift 3;
    for a in "$@";
    do
        $par $a;
    done
}
programlib_init
