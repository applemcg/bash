copyrightNotice () 
{ 
    comment "Copyright (C) 2005-2013, JYATL - Just Yet Another Testing Lab";
    comment "mailto: mcgowan (at) alum DOT mit DOT edu";
    comment bkup: appleton.home./users/applemcg/git/bash-functions/bin 2013_0821 203911;
}
cleanlib () 
{ 
    source fixlib;
    canonlib $*
}
collect_eval () 
{ 
    indir ~/bin cgrepf eval '*lib' | grep '1 *()' | field 1 | sort -u
}
defExe () 
{ 
    which $1 > /dev/null 2>&1 && echo $1 || echo $2
}
dodate () 
{ 
    echo "$1: $(date +%$1)"
}
f2 () 
{ 
    function f2_usage () 
    { 
        comment f2 function ...lib -- $*
    };
    isfunction $1 || { 
        f2_usage no Function $1;
        return 1
    };
    set -- $1 ~/git/bash-functions/bin/$2;
    existingfile $2 || { 
        f2_usage no File $2;
        return 1
    };
    fbdy $1 | append $2
}
ff () 
{ 
    fbdy $(functions $*)
}
field () 
{ 
    awk "{ print \$$1 }"
}
fmdos () 
{ 
    cat ${*:--} | tr -d '\015'
}
fname () 
{ 
    isfunction $1 && echo $1
}
getawk () 
{ 
    wh gawk || wh nawk || wh awk
}
gzfiles () 
{ 
    file ${*:-*.gz} | grep 'gzip compressed' | sed 's/:.*//'
}
iso_ymd () 
{ 
    date +%F
}
lc () 
{ 
    [ $# -gt 0 ] && { 
        echo $* | tr A-Z a-z
    } || { 
        cat - | tr A-Z a-z
    }
}
libfunc () 
{ 
    functions $*;
    comment obsolescent in behalf of functions
}
libfunctions () 
{ 
    functions $*;
    comment obsolescent in behalf of canonlib
}
loadedlibs () 
{ 
    sfg _init | sed 's/_init//'
}
lookat () 
{ 
    o=${1%txt}html;
    pmkdn $1 > $o;
    open $o
}
mac2unix () 
{ 
    cat ${*:--} | tr '\r' '\n';
    echo
}
nava () 
{ 
    eval echo $1 \$$1
}
newest () 
{ 
    comment TRACE newest $# TARGET "$1" DEPENDENT "$@";
    target="$1";
    shift;
    [[ -f "$target" ]] || { 
        comment NEWEST with NO $target;
        return 1
    };
    while [[ -n "$1" ]]; do
        [[ "$target" -ot "$1" ]] && { 
            comment NEWEST with $1 NEWER than $target;
            return 1
        };
        shift;
    done;
    comment NEWEST with $target as NEWEST argument;
    return 0
}
nonUnderscore () 
{ 
    grep -v _ $* /dev/null
}
obsolescent () 
{ 
    eval "$1() { comment OBSOLESCENT in behalf of $2; $2 \$@; }"
}
popla () 
{ 
    sort -n | field 1 | uniq -c
}
printfirst () 
{ 
    awk 'printed [$1]++ < 1' $*
}
programlib_ck () 
{ 
    function prodoclist () 
    { 
        programlib_doc | field 1 | sort
    };
    function pglibck () 
    { 
        case $1 in 
            2)
                comm -23 <( prodoclist) -;
                echo DOC, not LIB
            ;;
            1)
                comm -13 <( prodoclist) -;
                echo LIB, not DOC
            ;;
            3)
                comm -13 <( prodoclist) - | sed 's/$/	-- /'
            ;;
            *)
                comment "programlib_ck [123 {2}]";
                return
            ;;
        esac
    };
    functions ~/bin/programlib | sort | pglibck ${*:-2} | sort
}
programlib_doc () 
{ 
    cat  <<EOF
    
cgrepf		-- pattern file ... finds functions with pattern in files
cleanlib	-- to fixlib, uses canonlib
collect_eval	-- USES cgrepf, belongs whf cgrepf
defExe	-- ~ a b; echos "a", if found,  else "b"
dodate	-- ~ {x} :  date +%x
f2	-- ~ function {some}lib 
fedit 	-- Functions EDIT; ~ funs ...
ff	-- shorthand  fbdy functions ...
field	-- the Nth blank-separated field
fmdos	-- converts CR-LF files to NL
fname	-- echos function name
fofg	-- Files OF Grep -- at the end of a pipe
fun_finder	-- greps to find function name in saved 
gdoc	-- grep library documentaation; ~ lib [grep args]
getawk	-- who's your "awk"
ghfd	-- Grep History for Function Definitions
grepf 	-- lists function names and grep pattern lines in functions
gzfiles	-- inspects args, default to ..gz for gzip compressed
iso_ymd	-- : yyyy-mm-dd
latestFileIn	-- to gitlib, latest file in a treee
lc	-- Lower Case, see tolower, toupper, uc
libfunc	-- obsolescent on behalf of functions
libfunctions	--  obsolescent on behalf of functions
loadedlibs	-- : which libs are loaded
lookat	-- ~ text-in-markdown OPENS .HTML
mac2unix	-- like fmdos
nava	-- NAme VAlue 
newest	-- ~ FileA fileb ...  TRUE, when filea is the newest
nonUnderscore	-- lines w/o an Underscore
obsolescent	-- place holder for ~ 
obstolib	-- obsolescent creator
popla	-- POPuLAtion of a numeric First Field
printfirst	-- prints first occurrence of line of text
program_init	-- former programlib_init
programlib_ck	-- how to rebuild this list
programlib_doc	-- this list
qpfs	-- picks tokens from a function
repeated	-- ~ [n 2] => n..21
run_test	-- wraps "doit"
script_path	-- where is the source of this executable
self_ref	-- CONSTRUCTOR: namea nameb ...  "namea" lists namea ... z
setenv	-- ~ NAME Value,   just like the csh built-in
subtract	-- set subtraction 2nd list from first with comm -23
system	-- uname -s
today	-- YYMMDD
tolower	-- obsolescent in behalf of lc
toupper	-- obsolescent in behalf of uc, UC
uc	-- Upper Case
wh	-- which
wpl	-- output a Word Per Line
EOF

}
qpfs () 
{ 
    fbdy $* | grep -vE '(\(\)|^[{}]) *$' | wpl | sort -u
}
repeated () 
{ 
    count=${2:-2};
    result=;
    while [ $count -gt 0 ]; do
        result=$result$1;
        let count-=1;
    done;
    echo $result
}
run_test () 
{ 
    doit $*
}
script_path () 
{ 
    function _scrpath_zero () 
    { 
        while ( [ -h "$1" ] ); do
            set -- $(readlink "$1");
        done;
        pushd . > /dev/null;
        cd $(dirname "$1");
        pwd;
        popd > /dev/null
    };
    _scrpath_zero ${BASH_SOURCE[0]}
}
self_ref () 
{ 
    eval "$1 () { \${1:-echo} $*; }"
}
setenv () 
{ 
    eval $1=\"$2\";
    export $1
}
subtract () 
{ 
    cat ${2:--} | sort -u | comm -23 $1 -
}
system () 
{ 
    uname -s
}
today () 
{ 
    date +%Y%m%d
}
tolower () 
{ 
    tr '[A-Z]' '[a-z]'
}
toupper () 
{ 
    tr '[a-z]' '[A-Z]'
}
uc () 
{ 
    tr a-z A-Z
}
wh () 
{ 
    which $1
}
wpl () 
{ 
    cat ${*:--} | /usr/bin/tr -cs "[A-Z][a-z][0-9]_" '[\012*]'
}
fun_finder () 
{ 
    grep $* $(T shell_dirname)/.* /dev/null
}
program_init () 
{ 
    . ~/.profile;
    . shelllib;
    . smartflib;
    copyrightNotice 1>&2;
    obsolescent file_test testarg;
    obsolescent fileTest testarg;
    obsolescent piped pipe;
    obsolescent is_a_function isfunction;
    setenv AWK $(getawk);
    self_ref programlib_eval myfunctions obsolescent testarg self_ref;
    my_list program;
    comment self_ref my_list program_list program_init
}
latestFileIn () 
{ 
    find ${1:-git} -mtime -1 -type f | xargs ls -t | sed 1q
}
fofg () 
{ 
    sed 's/:.*//' $* /dev/null | sort -u
}
obstolib () 
{ 
    comment TRACE obstolib $# LIB $1 FUNCT $2 optional $3;
    set -- $1 $2 ${3:-${1}_$2};
    eval "$2 () { comment OBSOLESCENT $2 in behalf of $3; $3 \$@; }"
}
cgrepf () 
{ 
    grepf $* | awk -v gfor=$1 '$0 ~ /\(\) *$/ { save=$1; next }; {printf "%s\t%-15s\t%s\n",  gfor, save , $0}'
}
grepf () 
{ 
    p="$1";
    shift;
    cat ${*:--} | egrep "(^[a-zA-Z_][a-zA-Z0-9_]* *\(\) *$|$p)"
}
c2b () 
{ 
    comm -3 <( fs ~/bin/$1) <( fs $1)
}
gdoc () 
{ 
    doc=${1%lib}lib_doc;
    shift;
    $doc | grep ${*:-eval}
}
fedit () 
{ 
    fbdy $* > .y;
    vi .y;
    y
}
ghfd () 
{ 
    gh '()' | awk '$3 ~ /\(\)/ { print $2 }' | printfirst
}
qrf_insert () 
{ 
    set -- ${1%_qrf} ${2:-.z};
    set -- ${1%lib}lib_qrf $2;
    [[ -f $2 ]] || { 
        comment NO insertion file $2;
        return 2
    };
    declare -f $1 > /dev/null || { 
        comment NO function $1;
        return 1
    };
    comment TRACE qrf_insert $# LIB $1 INSERT $2;
    echo "$1 () { cat <<EOF";
    sort $2 <($1);
    echo EOF;
    echo "}"
}
programlib_qrf () 
{ 
    cat  <<EOF
    
cgrepf		-- pattern file ... finds functions with pattern in files
cleanlib	-- to fixlib, uses canonlib
collect_eval	-- USES cgrepf, belongs whf cgrepf
defExe	-- ~ a b; echos "a", if found,  else "b"
dodate	-- ~ {x} :  date +%x
f2	-- ~ function {some}lib 
fedit 	-- Functions EDIT; ~ funs ...
ff	-- shorthand  fbdy functions ...
field	-- the Nth blank-separated field
fmdos	-- converts CR-LF files to NL
fname	-- echos function name
fofg	-- Files OF Grep -- at the end of a pipe
fun_finder	-- greps to find function name in saved 
getawk	-- who's your "awk"
ghfd	-- Grep History for Function Definitions
gqrf	-- grep library documentaation; ~ lib [grep args]
grepf 	-- lists function names and grep pattern lines in functions
gzfiles	-- inspects args, default to ..gz for gzip compressed
iso_ymd	-- : yyyy-mm-dd
latestFileIn	-- to gitlib, latest file in a treee
lc	-- Lower Case, see tolower, toupper, uc
libfunc	-- obsolescent on behalf of functions
libfunctions	--  obsolescent on behalf of functions
loadedlibs	-- : which libs are loaded
lookat	-- ~ text-in-markdown OPENS .HTML
mac2unix	-- like fmdos
nava	-- NAme VAlue 
newest	-- ~ FileA fileb ...  TRUE, when filea is the newest
nonUnderscore	-- lines w/o an Underscore
obsolescent	-- place holder for ~ 
obstolib	-- obsolescent creator
popla	-- POPuLAtion of a numeric First Field
printfirst	-- prints first occurrence of line of text
program_init	-- former programlib_init
programlib_ck	-- how to rebuild this list
programlib_qrf	-- this list
qpfs	-- picks tokens from a function
qrf_insert	-- add function QRFs, one-liners to LIB_qrf; ~ library [file|.z]
repeated	-- ~ [n 2] => n..21
run_test	-- wraps "doit"
script_path	-- where is the source of this executable
self_ref	-- CONSTRUCTOR: namea nameb ...  "namea" lists namea ... z
setenv	-- ~ NAME Value,   just like the csh built-in
subtract	-- set subtraction 2nd list from first with comm -23
system	-- uname -s
today	-- YYMMDD
tolower	-- obsolescent in behalf of lc
toupper	-- obsolescent in behalf of uc, UC
uc	-- Upper Case
wh	-- which
wpl	-- output a Word Per Line
EOF

}
UC () 
{ 
    [ $# -gt 0 ] && { 
        echo $* | tr a-z A-Z
    } || { 
        cat - | tr a-z A-Z
    }
}
needfun () 
{ 
    ignore pushd ~/bin;
    whf $1;
    ignore popd
}
getHref () 
{ 
    comment TRACE getHref $# DIR $1;
    foreachi lnfile ${1:-..} $(localhref)
}
localhref () 
{ 
    comment TRACE localhref $# PWD $PWD;
    grep 'a href="' *.html | sed '
            s/:.*href="/ /;s/".*//
        ' | egrep -v '(\#|:)' | field 2 | sort -u
}
lnfile () 
{ 
    comment TRACE lnfile $# DIR $1 FILE $2;
    comment linfile needs to defend against ../names in $2;
    [[ -f $2 ]] && return;
    g=$1/$2;
    [[ -f $g ]] || { 
        comment NO file $g to link to $f;
        return
    };
    doit ln $g .
}
ifdiff () 
{ 
    comment TRACE ifdiff SOURCE $1 DESTINATION $2;
    exists $1 || return;
    exists $2 || cp /dev/null $2;
    ignore diff $1 $2 && return 1;
    doit mv $1 $2;
    return 0
}
ghlibs () 
{ 
    gh append | grep 'lib$' | field NF | printfirst
}
my_list () 
{ 
    eval "${1}_list () { \${1:-echo} \$(functions $(which ${1}lib)); }"
}
pro_funs () 
{ 
    functions ~/.profile;
    functions ~/bin/.profile
}
program_init
my_list () 
{ 
    set -- ${1%lib};
    eval "${1}_list () { \${1:-echo} \$(functions $(which ${1}lib)); }"
}
program_funs () 
{ 
    pro_funs;
    shell_list;
    smartf_list;
    program_list
}
