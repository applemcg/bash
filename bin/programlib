programlib_init () 
{ 
    . ~/.profile

    comment "Copyright (C) 2011-2013, JYATL -- Just YA Testing Lab";
    comment "mailto: mcgowan (at) alum DOT mit DOT edu";

    obsolescent file_test testarg;
    obsolescent fileTest testarg;
    obsolescent piped pipe;
    obsolescent is_a_function isfunction;
    setenv AWK $(getawk);
    testarg empty z;
    testarg executable x;
    testarg existingdir d;
    testarg exists e;
    testarg existingfile f;
    testarg nonempty s;
    testarg writeable w;
    self_ref programlib_eval myfunctions obsolescent rlib testarg self_ref
}
stdout () 
{ 
    $(shifted $@) > $1
}
pipe () 
{ 
    eval $(shifted $@) | $1
}
run_test () 
{ 
    doit $*
}
foreach () 
{ 
    local cmd=$1;
    shift;
    for arg in "$@";
    do
        $cmd $arg;
    done
}
shifted () 
{ 
    shift;
    echo "$@"
}
liblib_obsolescent () 
{ 
    foreach rlib $(liblib_users)
}
Mkdir () 
{ 
    doit mkdir -p $*
}
setenv () 
{ 
    eval $1=\"$2\";
    export $1
}
libfunc () 
{ 
    functions $*;
    comment obsolescent in behalf of functions
}
obsolescent () 
{ 
    eval "$1() { comment OBSOLESCENT in behalf of $2; $2 \$@; }"
}
nonUnderscore () 
{ 
    grep -v _ $*
}
wh () 
{ 
    which $1
}
getawk () 
{ 
    wh gawk || wh nawk || wh awk
}
error () 
{ 
    comment "$@";
    exit $#
}
foreachi () 
{ 
    local par="$1 $2";
    shift 2;
    for a in "$@";
    do
        $par $a;
    done
}
shift2 () 
{ 
    shift;
    shift;
    echo $*
}
not () 
{ 
    if { 
        eval "$@"
    }; then
        false;
    else
        true;
    fi
}
dirname () 
{ 
    case $1 in 
        */*)
            echo ${1%/*}
        ;;
        *)
            echo .
        ;;
    esac
}
basename () 
{ 
    echo ${1##*/}
}
newest () 
{ 
    target=$1;
    shift;
    [[ -f $target ]] || {
        comment NEWEST with NO $target
        return 1;
	}
    while [[ -n $1 ]]; do
        [[ $target -ot $1 ]] && {
	   comment NEWEST with $1 NEWER than $target
	   return 1;
	   }
        shift;
    done;
    return 0
}
wpl () 
{ 
    cat ${*:--} | /usr/bin/tr -cs "[A-Z][a-z][0-9]_" '[\012*]'
}
toupper () 
{ 
    tr '[a-z]' '[A-Z]'
}
tolower () 
{ 
    tr '[A-Z]' '[a-z]'
}
subtract () 
{ 
    cat ${2:--} | sort -u | comm -23 $1 -
}
field () 
{ 
    awk "{ print \$$1 }"
}
indir () 
{ 
    ignore pushd $1;
    shift;
    $@;
    ignore popd
}
nava () 
{ 
    eval echo $1 \$$1
}
printfirst () 
{ 
    awk 'printed [$1]++ < 1' $*
}
cleanlib () 
{ 
    source fixlib;
    canonlib $*
}
libfunctions () 
{ 
    functions $*;
    comment obsolescent in behalf of canonlib
}
testarg () 
{ 
    eval "$1() { [[ -$2 \$1 ]]; }"
}
fnames () 
{ 
    [[ -d .names ]] || mkdir -p .names;
    suf=${1:-stdin};
    libfunc $* | tee .names.$suf | sort -u > .names/$suf;
    cat .names.$suf && rm -f .names.$suf
}
system () 
{ 
    uname -s
}
uc () 
{ 
    tr a-z A-Z
}
lc () 
{ 
    cat ${*:--} | tr '[A-Z]' '[a-z]'
}
today () 
{ 
    date +%Y%m%d
}
programlib_ck () 
{ 
    function pglibck () 
    { 
        case $1 in 
            2)
                comm -23 .program.doc -;
                echo DOC, not LIB
            ;;
            1)
                comm -13 .program.doc -;
                echo LIB, not DOC
            ;;
            3)
                comm -13 .program.doc - | sed 's/$/	-- /'
            ;;
            *)
                comment "programlib_ck [123 {2}]";
                return
            ;;
        esac
    };
    programlib_doc | field 1 | sort > .program.doc;
    functions ~/bin/programlib | sort | pglibck ${*:-2} | sort | tee .program.nxt
}
programlib_doc () 
{ 
    cat  <<'EOF'

    
Mkdir	-- superseeded by mkdir -p
append	-- stdin to a file
basename	-- file portion of the argument, see dirname
bitbucket	-- should be IGNORE
collect_eval	-- USES cgrepf, belongs whf cgrepf
defExe	-- ~ a b; echos "a", if found,  else "b"
dirname	-- the directory portion of the argument, default "."
dodate	-- ~ {x} :  date +%x
error	-- comment, then exit
f2	-- ~ function {some}lib 
f2_usage
field	-- the Nth blank-separated field
fmdos	-- converts CR-LF files to NL
fnames	-- wrap on libfunc, 
foreach	-- ~ cmd ...   execuctes  "cmd" on each arg
foreachi	-- ~ cmd One arg ... executes "cmd One" on each arg
foreachij	-- ~ cmd a b ..i... executes "cmd a b i" on each i
getawk	-- who's your "awk"
indir	-- ~ DIR cmd ...  executes "cmd ..." in DIR
iso_y-m-d	-- : yyyy-mm-dd
lc	-- Lower Case, see tolower, toupper, uc
libfunc	-- obsolescent on behalf of functions
libfunctions	--  obsolescent on behalf of functions
liblib_obsolescent	-- USES rlib on liblib_users
loadedlibs	-- : which libs are loaded
lookat	-- ~ text-in-markdown OPENS .HTML
mac2unix	-- like fmdos
nava	-- NAme VAlue 
newest	-- ~ FileA fileb ...  TRUE, when filea is the newest
nonUnderscore	-- lines w/o an Underscore
not	-- ~ cmd ... inverts logical sense of the cmd ...
obsolescent	-- place holder for ~ 
onlydirs	-- the directories in $*
onlyfiles	-- the files
pipe	-- ~ a b c ...;  b c ... > a
popla	-- POPuLAtion of a numeric First Field
printfirst	-- prints first occurrence of line of text
programlib_ck	-- how to rebuild this list
programlib_doc	-- this list
programlib_init	-- source ...
quiet	-- executes command, disposing stderr. "quiet ignore ... "
repeated	-- ~ [n 2] => n..21
run_test	-- wraps "doit"
script_path	-- where is the source of this executable
self_ref	-- CONSTRUCTOR: namea nameb ...  "namea" lists namea ... z
setenv	-- ~ NAME Value,   just like the csh built-in
shift2	-- ~ a b c d e ... returns "c d e ..."
shifted	-- ~ a b c d e ... returns "b c d e ..."
stdout	-- ~ arg cmd args ...  "cmd args ... > arg"
subtract	-- set subtraction 2nd list from first with comm -23
system	-- uname -s
testarg	-- CONSTRUCTOR: ~ name [a-z]; creates "name", function uses test arg
today	-- YYMMDD
tolower	-- obsolescent in behalf of lc
toupper	-- obsolescent in behalf of uc, UC
uc	-- Upper Case
wh	-- which
wpl	-- output a Word Per Line
    
EOF

}
self_ref () 
{ 
    eval "$1 () { \${1:-echo} $*; }"
}
bitbucket () 
{ 
    eval $@ 2> /dev/null
}
onlyfiles () 
{ 
    for arg in ${*:-*};
    do
        [[ -f $arg ]] && echo $arg;
    done
}
onlydirs () 
{ 
    for arg in ${*:-*};
    do
        [[ -d $arg ]] && echo $arg;
    done
}
fmdos () 
{ 
    cat ${*:--} | tr -d '\015'
}
append () 
{ 
    tee -a $1
}
script_path () 
{ 
    function _scrpath_zero () 
    { 
        while ( [ -h "$1" ] ); do
            set -- $(readlink "$1");
        done;
        pushd . > /dev/null;
        cd $(dirname "$1");
        pwd;
        popd > /dev/null
    };
    _scrpath_zero ${BASH_SOURCE[0]}
}
defExe () 
{ 
    which $1 > /dev/null 2>&1 && echo $1 || echo $2
}
repeated () 
{ 
    count=${2:-2};
    result=;
    while [ $count -gt 0 ]; do
        result=$result$1;
        let count-=1;
    done;
    echo $result
}
popla () 
{ 
    sort -n | field 1 | uniq -c
}
mac2unix () 
{ 
    cat ${*:--} | tr '\r' '\n';
    echo
}
collect_eval () 
{ 
    indir ~/bin cgrepf eval '*lib' | grep '1 *()' | field 1 | sort -u
}
foreachij () 
{ 
    local par="$1 $2 $3";
    shift 3;
    for a in "$@";
    do
        $par $a;
    done
}
quiet () 
{ 
    $@ 2> /dev/null
}
iso_y-m-d () 
{ 
    date +%F
}
lookat () 
{ 
    o=${1%txt}html;
    pmkdn $1 > $o;
    open $o
}
dodate () 
{ 
    echo "$1: $(date +%$1)"
}
loadedlibs () 
{ 
    sfg _init | sed 's/_init//'
}
f2 () 
{ 
    f2_usage () { comment f2 function ...lib -- $*; }
    isfunction $1 || { f2_usage no Function $1; return 1; }
    set -- $1 ~/git/bash-functions/bin/$2
    existingfile $2 || { f2_usage no File $2; return 1; }
    fbdy $1 | append $2
}
programlib_init
qpfs () 
{ 
    fbdy $* | egrep -v '(\(\)|^[{}]) *$' | wpl | sort -u
}
fname () 
{ 
    isfunction $1 && echo $1
}
