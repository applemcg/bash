### Listlib -- lists for the shell

The bash shell has arrays.  They seem like an easy way to model lists.
I didn't find it that easy.  Here a __list__ is a _blank-separated_
string in an ordinary shell variable, __export__ed to the ENVIRONMENT.

The `list` command, with one argument displays the items in that list;
with more arguments it appends them to the list.

A set of sub-commands, all named `list_`*sub-command*, do the
sensible things.  The only difficulty you might have is how to
remember the difference between sub-commands `delete` and `remove` The
`list_delete name` deletes the named list and `list_remove name item
...` removes the items from the list.  Imagine a _remove_ (or
_delete_) command where only one argument deletes the whole list.  It
seemed prudent to use separate names to avoid the mistake.

Attempts to `delete` with multiple arguments or `remove` with only one
argument produce a warning.

The commands do nothing sensibly, and without complaint.

Lists preserve insertion order; they don't defend against multiple 
insertions, and, as of this moment, don't have a membership test.
Maybe you could write one and send it to me.

### The sub-commands

A sub command is invoked: `list_add name item ...`, with an underscore
after "list" and before the sub-command name.  In this example, "name"
is the list name, and item ... are the items for the list.

Here is a brief synopsis of each:

* add      -- __name__ item ...
* delete   -- __name__
* help     -- displays the __qrf__ and a help message
* init     -- default __traceon__ and shows the help
* lists    -- shows the current lists (their names)
* qrf      -- __Q__uick __R__e__F__erence, lists functions
* remove   -- __name__ item ...
* show     -- __name__  # same as `list name`
* test     -- runs a demonstration test case
* trace    -- internal function to divert the tracing
               to the bit-bucket, or standard error
* traceoff -- tracing goes to the bit-bucket (*/dev/null*)
* traceon  -- to the standard error 

### Implementation details

Right now, a list is a simple shell variable named **l**\_*name*. Don't
count on it forever.

The only trick in the code is in the `list_remove` function. Since the
items are blank-separated, when deleting an item which is either the
first or the last, there may not be a leading or trailing blank to
match. So compare the space-surrounded item to remove with the
space-surrounded list of items.  The bash shell has a handy means to
trim the item.  Here's the code to remove the __rm__ string from the
old list __ol__:

    function unlist () 
    { 
        ol=" $(items $1) ";
        rm=" $2 ";
        echo ${ol/$rm/ }
    };

To view the test case for examples, just `declare -f list_test`, or any
function for that matter. 

Notice how `list_init` works. The only executable statement in any of my
functon library's is a call to the local **init** function.

### References

  [mkdown]: http://daringfireball.net/projects/markdown/ "Daring Fireball, John Gruber"

1. Here is the [library code](../bin/listlib). Save it on your PATH and 
   _source_ it, e.g. `source listlib` 
2. Here is [this source text](../explain/listlib.txt).
3. Formatting brought to you by [Markdown][mkdown]
3. <a href="mailto:mcgowan@alum.mit.edu">Your Author</a>
